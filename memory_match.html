<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>‚ú® Memory Match - Emoji Pairs ‚ú®</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Poppins', sans-serif;
    }

    body {
      background: radial-gradient(circle at top left, #6a11cb, #2575fc);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }

    #gameContainer {
      position: relative;
      width: 100%;
      max-width: 900px;
      height: 90vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    #gameCanvas {
      border-radius: 20px;
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.15);
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(15px);
      border: 2px solid rgba(255, 255, 255, 0.2);
      width: 100%;
      height: auto;
    }

    .screen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.9);
      border-radius: 25px;
      padding: 40px;
      text-align: center;
      width: 90%;
      max-width: 400px;
      box-shadow: 0 0 40px rgba(0, 0, 0, 0.25);
      transition: 0.4s ease;
    }

    .hidden {
      display: none;
    }

    h1 {
      font-size: 2.5em;
      color: #222;
      margin-bottom: 10px;
    }

    h2 {
      color: #555;
      margin: 15px 0;
    }

    button {
      background: linear-gradient(135deg, #ff9966, #ff5e62);
      color: white;
      border: none;
      padding: 12px 25px;
      border-radius: 25px;
      font-size: 1.1em;
      cursor: pointer;
      margin: 10px;
      transition: all 0.3s ease;
    }

    button:hover {
      transform: translateY(-3px);
      box-shadow: 0 4px 15px rgba(255, 94, 98, 0.5);
    }

    #themeSelection, #difficultySelection {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }

    .theme-btn {
      background: linear-gradient(135deg, #667eea, #764ba2);
    }

    .diff-btn {
      background: linear-gradient(135deg, #43cea2, #185a9d);
    }

    .leaderboard {
      max-height: 200px;
      overflow-y: auto;
      margin-top: 15px;
      border-top: 1px solid #ddd;
      padding-top: 10px;
    }

    .leaderboard-item {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    }

    input {
      padding: 10px;
      border-radius: 20px;
      border: 1px solid #ccc;
      outline: none;
      width: 80%;
      margin: 10px auto;
      display: block;
      text-align: center;
    }

    .stats-overlay {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: #fff;
      font-size: 1.1em;
      text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.4);
      background: rgba(0, 0, 0, 0.3);
      padding: 10px 25px;
      border-radius: 20px;
      letter-spacing: 0.5px;
      display: none;
    }

    @keyframes glow {
      0% { box-shadow: 0 0 10px rgba(255,255,255,0.3); }
      50% { box-shadow: 0 0 25px rgba(255,255,255,0.7); }
      100% { box-shadow: 0 0 10px rgba(255,255,255,0.3); }
    }

    #gameCanvas {
      animation: glow 2s infinite;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <div id="statsOverlay" class="stats-overlay">
      ‚è± <span id="timeDisplay">0</span>s |
      üéØ <span id="movesDisplay">0</span> |
      üíñ <span id="pairsDisplay">0</span>
    </div>

    <!-- Menu -->
    <div id="menuScreen" class="screen">
      <h1>üß† Memory Match</h1>
      <h2>Select Difficulty</h2>
      <div id="difficultySelection">
        <button class="diff-btn" data-diff="easy">Easy</button>
        <button class="diff-btn" data-diff="medium">Medium</button>
        <button class="diff-btn" data-diff="hard">Hard</button>
      </div>
      <h2>Select Theme</h2>
      <div id="themeSelection">
        <button class="theme-btn" data-theme="animals">üêæ Animals</button>
        <button class="theme-btn" data-theme="food">üçï Food</button>
        <button class="theme-btn" data-theme="symbols">‚≠ê Symbols</button>
        <button class="theme-btn" data-theme="travel">‚úàÔ∏è Travel</button>
      </div>
      <button id="viewLeaderboardBtn">üèÜ Leaderboard</button>
      <p style="margin-top:10px;color:#666;font-size:0.9em">
        ‚å®Ô∏è Shortcuts: R = Restart | L = Leaderboard | Esc = Menu
      </p>
    </div>

    <!-- Game Over -->
    <div id="gameOverScreen" class="screen hidden">
      <h1>üéâ You Won!</h1>
      <h2>Great job!</h2>
      <p>Time: <span id="finalTime">0</span>s</p>
      <p>Moves: <span id="finalMoves">0</span></p>
      <input type="text" id="playerName" placeholder="Enter your name" maxlength="15">
      <button id="saveScoreBtn">üíæ Save Score</button>
      <button id="playAgainBtn">üîÅ Play Again</button>
      <button id="menuBtn">üè† Main Menu</button>
    </div>

    <!-- Leaderboard -->
    <div id="leaderboardScreen" class="screen hidden">
      <h1>üèÜ Leaderboard</h1>
      <div id="leaderboardList" class="leaderboard"></div>
      <button id="backToMenuBtn">‚¨ÖÔ∏è Back</button>
    </div>
  </div>

  <script>
    class MemoryGame {
      constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        this.gameState = 'menu';
        this.cards = [];
        this.selectedCards = [];
        this.matchedPairs = 0;
        this.totalPairs = 0;
        this.moves = 0;
        this.time = 0;
        this.timerInterval = null;
        this.currentTheme = 'animals';
        this.difficulty = 'medium';
        this.leaderboard = [];

        this.themes = {
          animals: ['üê∂','üê±','üê≠','üêπ','üê∞','ü¶ä','üêª','üêº','üê®','üêØ'],
          food: ['üçé','üçï','üçî','üçü','üç¶','üç©','üç™','üçâ','üç∞','ü•ó'],
          symbols: ['‚≠ê','‚ù§Ô∏è','üåü','‚ö°','üíé','üéØ','üé®','üî•','üí´','üí°'],
          travel: ['üöó','‚úàÔ∏è','üöÄ','üö¢','üèñÔ∏è','üó∫Ô∏è','üèîÔ∏è','üèõÔ∏è','üöâ','üö≤']
        };

        this.setupInput();
        this.loadLeaderboard();
        this.gameLoop();
      }

      setupInput() {
        // Mouse
        this.canvas.addEventListener('click', e => this.handleClick(e));

        // Keyboard shortcuts
        document.addEventListener('keydown', e => {
          if (e.code === 'KeyR' && this.gameState === 'playing') this.startGame();
          if (e.code === 'KeyL') this.showLeaderboard();
          if (e.code === 'Escape') this.showMenu();
        });

        // Difficulty select
        document.querySelectorAll('.diff-btn').forEach(btn => {
          btn.addEventListener('click', e => {
            this.difficulty = e.target.dataset.diff;
          });
        });

        // Theme select
        document.querySelectorAll('.theme-btn').forEach(btn => {
          btn.addEventListener('click', e => {
            this.currentTheme = e.target.dataset.theme;
            this.startGame();
          });
        });

        // Buttons
        document.getElementById('viewLeaderboardBtn').addEventListener('click', () => this.showLeaderboard());
        document.getElementById('saveScoreBtn').addEventListener('click', () => this.saveScore());
        document.getElementById('playAgainBtn').addEventListener('click', () => this.startGame());
        document.getElementById('menuBtn').addEventListener('click', () => this.showMenu());
        document.getElementById('backToMenuBtn').addEventListener('click', () => this.showMenu());
      }

      handleClick(event) {
        if (this.gameState !== 'playing') return;

        const rect = this.canvas.getBoundingClientRect();
        const x = (event.clientX - rect.left) * (this.canvas.width / rect.width);
        const y = (event.clientY - rect.top) * (this.canvas.height / rect.height);

        this.cards.forEach(card => {
          if (this.isPointInCard(x, y, card) && !card.matched && !card.flipped) {
            if (this.selectedCards.includes(card)) return;
            this.flipCard(card);
          }
        });
      }

      isPointInCard(x, y, card) {
        return x >= card.x && x <= card.x + card.width &&
               y >= card.y && y <= card.y + card.height;
      }

      startGame() {
        this.gameState = 'playing';
        this.matchedPairs = 0;
        this.moves = 0;
        this.time = 0;
        this.selectedCards = [];
        this.createCards();
        this.hideAllScreens();
        document.getElementById('statsOverlay').style.display = 'block';

        if (this.timerInterval) clearInterval(this.timerInterval);
        this.timerInterval = setInterval(() => {
          this.time++;
        }, 1000);
      }

      createCards() {
        this.cards = [];
        const emojis = [...this.themes[this.currentTheme]];
        if (this.difficulty === 'easy') this.totalPairs = 4;
        else if (this.difficulty === 'medium') this.totalPairs = 6;
        else this.totalPairs = 8;

        let pairs = [];
        for (let i = 0; i < this.totalPairs; i++) {
          pairs.push(emojis[i], emojis[i]);
        }
        pairs.sort(() => Math.random() - 0.5);

        const cols = 4;
        const rows = Math.ceil(pairs.length / cols);
        const pad = 10;
        const cardW = (this.canvas.width - (cols + 1) * pad) / cols;
        const cardH = (this.canvas.height - (rows + 1) * pad) / rows;

        for (let i = 0; i < pairs.length; i++) {
          const row = Math.floor(i / cols);
          const col = i % cols;
          this.cards.push({
            x: col * (cardW + pad) + pad,
            y: row * (cardH + pad) + pad,
            width: cardW,
            height: cardH,
            emoji: pairs[i],
            flipped: false,
            matched: false
          });
        }
      }

      flipCard(card) {
        if (this.selectedCards.length >= 2) return;
        card.flipped = true;
        this.selectedCards.push(card);
        this.playSound('flip');

        if (this.selectedCards.length === 2) {
          this.moves++;
          this.checkMatch();
        }
      }

      checkMatch() {
        const [a, b] = this.selectedCards;
        if (a.emoji === b.emoji) {
          a.matched = b.matched = true;
          this.matchedPairs++;
          this.playSound('match');
          if (this.matchedPairs === this.totalPairs) this.gameOver();
        } else {
          setTimeout(() => {
            a.flipped = b.flipped = false;
            this.playSound('no-match');
          }, 800);
        }
        setTimeout(() => this.selectedCards = [], 800);
      }

      gameOver() {
        this.gameState = 'gameover';
        clearInterval(this.timerInterval);
        document.getElementById('statsOverlay').style.display = 'none';
        document.getElementById('finalTime').textContent = this.time;
        document.getElementById('finalMoves').textContent = this.moves;
        this.hideAllScreens();
        document.getElementById('gameOverScreen').classList.remove('hidden');
        this.playSound('win');
      }

      showMenu() {
        clearInterval(this.timerInterval);
        this.hideAllScreens();
        document.getElementById('menuScreen').classList.remove('hidden');
        document.getElementById('statsOverlay').style.display = 'none';
      }

      hideAllScreens() {
        document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
      }

      showLeaderboard() {
        this.hideAllScreens();
        document.getElementById('leaderboardScreen').classList.remove('hidden');
        this.updateLeaderboardDisplay();
      }

      saveScore() {
        const name = document.getElementById('playerName').value.trim() || 'Player';
        this.leaderboard.push({
          name, time: this.time, moves: this.moves,
          theme: this.currentTheme, difficulty: this.difficulty,
          date: new Date().toLocaleDateString()
        });
        this.leaderboard.sort((a,b) => a.time - b.time || a.moves - b.moves);
        this.leaderboard = this.leaderboard.slice(0,10);
        this.saveLeaderboard();
        this.showLeaderboard();
      }

      loadLeaderboard() {
        const data = localStorage.getItem('memoryLeaderboard');
        if (data) this.leaderboard = JSON.parse(data);
      }

      saveLeaderboard() {
        localStorage.setItem('memoryLeaderboard', JSON.stringify(this.leaderboard));
      }

      updateLeaderboardDisplay() {
        const list = document.getElementById('leaderboardList');
        list.innerHTML = '';
        this.leaderboard.forEach((s,i) => {
          const div = document.createElement('div');
          div.className = 'leaderboard-item';
          div.innerHTML = `<span>${i+1}. ${s.name}</span>
            <span>${s.time}s | ${s.moves} | ${s.difficulty}</span>`;
          list.appendChild(div);
        });
      }

      playSound(type) {
        try {
          const osc = this.audioCtx.createOscillator();
          const gain = this.audioCtx.createGain();
          osc.connect(gain);
          gain.connect(this.audioCtx.destination);
          const tones = {
            flip: [523, 0.05],
            match: [784, 0.1],
            'no-match': [220, 0.05],
            win: [1046, 0.2]
          };
          const [freq, vol] = tones[type];
          osc.frequency.value = freq;
          gain.gain.value = vol;
          osc.start();
          osc.stop(this.audioCtx.currentTime + 0.25);
        } catch (e) {}
      }

      render() {
        this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
        if (this.gameState === 'playing') {
          this.cards.forEach(c => {
            this.ctx.save();
            this.ctx.translate(c.x + c.width/2, c.y + c.height/2);
            this.ctx.fillStyle = c.flipped || c.matched ? '#fff' : 'rgba(255,255,255,0.2)';
            this.ctx.fillRect(-c.width/2, -c.height/2, c.width, c.height);
            this.ctx.font = `${c.height*0.5}px Poppins`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            if (c.flipped || c.matched) this.ctx.fillText(c.emoji,0,0);
            this.ctx.restore();
          });
          document.getElementById('timeDisplay').textContent = this.time;
          document.getElementById('movesDisplay').textContent = this.moves;
          document.getElementById('pairsDisplay').textContent = `${this.matchedPairs}/${this.totalPairs}`;
        }
      }

      gameLoop() {
        this.render();
        requestAnimationFrame(() => this.gameLoop());
      }
    }

    new MemoryGame();
  </script>
</body>
</html>
